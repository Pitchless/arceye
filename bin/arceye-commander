#!/usr/bin/env python

from __future__ import print_function
import sys, os
import yaml
from arceye import *
import pygame

# Read config from command line if set
config = {}
config_file = None
if len(sys.argv) > 1:
    config_file = sys.argv[1]
    config = yaml.load(file(sys.argv[1]))

dead_zone = 0.1
if config.has_key('dead_zone'): dead_zone = config['dead_zone']
# Used to scale the joystick axis
max_pwm_yaw = 50
max_pwm_pitch = 50
max_pwm_lid = 120
if config.has_key('max_pwm_yaw'): max_pwm_yaw = config['max_pwm_yaw']
if config.has_key('max_pwm_pitch'): max_pwm_pitch = config['max_pwm_pitch']
if config.has_key('max_pwm_lid'): max_pwm_lid = config['max_pwm_lid']


# This is a simple pygame class that will help us print to the screen
class TextPrint:
    def __init__(self, screen, text_color=(0,255,0), font=None):
        self.reset()
        self.screen     = screen
        self._font      = pygame.font.Font(None, 20) if not font else font
        self.text_color = text_color

    def text(self, textString):
        textBitmap = self._font.render(textString, True, self.text_color)
        self.screen.blit(textBitmap, [self.x, self.y])
        self.y += self.line_height

    def reset(self):
        self.x = 10
        self.y = 10
        self.line_height = 15

    def indent(self):
        self.x += 10

    def unindent(self):
        self.x -= 10

    def color(self,r,g,b):
        self.text_color = (r,g,b)

    def font(self,name,size=12):
        self._font = pygame.font.Font(pygame.font.match_font(name), size)


# Util func to clamp a value in a deadzone
def dead_zoned(val, dead_zone=dead_zone):
    if val > -dead_zone and val < dead_zone:
        return 0
    return val

# If pid is running set target else raw command
def joint_ui_command(joint,val):
    if joint.active: # pid is running
        joint.target += val
    else:
        joint.command += val

# Setup the eye
eye = ArcEye()
eye.load_config(config_file)

# Start the gui
pygame.init()
pygame.display.set_caption("ArcEye")
screen = pygame.display.set_mode( (320,620) )
screen.fill((0, 0, 0))
guitxt = TextPrint(screen)
#loginfo("Fonts: %s"%pygame.font.get_fonts())
guitxt.font("droidsansmono", 14)

# Grab the joystick
joystick = None
pygame.joystick.init()
try:
    joystick = pygame.joystick.Joystick(0)
    joystick.init()
    loginfo("Joystick 0")
except pygame.error as e:
    logerr("Joystick fail %s"%e)

# Main loop
frame = 0
done = False
show_help = False
while not done:
        frame += 1

        eye.read_status()

        # Joystick and other events
        for event in pygame.event.get(): # User did something
            if event.type == pygame.QUIT: # If user clicked close
                done=True # Flag that we are done so we exit this loop
            elif event.type == pygame.JOYAXISMOTION:
                eye.yaw.command = dead_zoned(joystick.get_axis(0)) * max_pwm_yaw;
                eye.pitch.command = dead_zoned(joystick.get_axis(1)) * max_pwm_pitch;
                eye.lid.command = dead_zoned(joystick.get_axis(2)) * max_pwm_lid;
            if event.type == pygame.JOYBUTTONDOWN:
                print("Joystick button pressed.")
            if event.type == pygame.JOYBUTTONUP:
                print("Joystick button released.")

        # Keyboard shortcuts
        keys = pygame.key.get_pressed()
        if keys[pygame.K_ESCAPE]:
                done = True
        elif keys[pygame.K_SPACE]:
            for j in eye.all_joints():
                j.command = 0
                j.active = False
        elif keys[pygame.K_0]:
            for j in eye.all_joints():
                j.target = 0
        elif keys[pygame.K_F1]:
            show_help = False if show_help else True
        elif keys[pygame.K_a]:
            joint_ui_command(eye.yaw, 1)
        elif keys[pygame.K_d]:
            joint_ui_command(eye.yaw, -1)
        elif keys[pygame.K_w]:
            joint_ui_command(eye.pitch, 1)
        elif keys[pygame.K_s]:
            joint_ui_command(eye.pitch, -1)
        elif keys[pygame.K_e]:
            joint_ui_command(eye.lid, 1)
        elif keys[pygame.K_q]:
            joint_ui_command(eye.lid, -1)
        # Brakes
        elif keys[pygame.K_r]:
            eye.yaw.brake_cmd = 1
        elif keys[pygame.K_f]:
            eye.yaw.brake_cmd = 0
        elif keys[pygame.K_t]:
            eye.pitch.brake_cmd = 1
        elif keys[pygame.K_g]:
            eye.pitch.brake_cmd = 0
        elif keys[pygame.K_y]:
            eye.lid.brake_cmd = 1
        elif keys[pygame.K_h]:
            eye.lid.brake_cmd = 0
        # Controllers on/off
        elif keys[pygame.K_1]:
            eye.yaw.toggle_active()
        elif keys[pygame.K_2]:
            eye.pitch.toggle_active()
        elif keys[pygame.K_3]:
            eye.lid.toggle_active()

        # Update the eye and it's joints (runs their pids)
        eye.update()

        # Update the display
        if show_help:
            screen.fill((0,0,0))
            guitxt.reset()
            guitxt.color(255,255,0)
            guitxt.text("**** ArcEye ***")
            guitxt.text("")
            guitxt.text("ESC - Quit")
            guitxt.text("F1  - Show/hide this help")
            guitxt.text("SPACE  - Zero commands and controllers.")
            guitxt.text("a - yaw left")
            guitxt.text("d - yaw right")
            guitxt.text("w - pitch up")
            guitxt.text("s - pitch down")
            guitxt.text("1 - toggle yaw controller (PID)")
            guitxt.text("2 - toggle pitch controller (PID)")
            guitxt.text("3 - toggle lid controller (PID)")
            guitxt.text("r,f - yaw brake on,off")
            guitxt.text("t,g - pitch brake on,off")
            guitxt.text("w,h - lid brake on,off")
            guitxt.text("")
            guitxt.text("Left Stick - yaw")
            guitxt.text("Right Stick - pitch")
            guitxt.text("Left Trigger - lid")
        else:
            screen.fill((0,0,0))
            guitxt.reset()
            guitxt.color(255,255,0)
            guitxt.text("Frame: %s"%eye.frame)
            guitxt.text("Connected: %s"%eye.is_connected)
            if eye.bat_volt1 < 18: # over
                guitxt.color(255,0,0)
            if eye.bat_volt1 < 14: # normal
                guitxt.color(0,255,0)
            if eye.bat_volt1 < 11: # under
                guitxt.color(255,123,0)
            guitxt.text("Battery Volt 1: %s"%eye.bat_volt1)
            if eye.bat_volt2 < 18: # over
                guitxt.color(255,0,0)
            if eye.bat_volt2 < 14: # normal
                guitxt.color(0,255,0)
            if eye.bat_volt2 < 11: # under
                guitxt.color(255,123,0)
            guitxt.text("Battery Volt 2: %s"%eye.bat_volt2)
            guitxt.text("")
            for j in eye.all_joints():
                guitxt.color(255,255,0)
                guitxt.text(j.name)
                guitxt.color(0,255,0)
                guitxt.indent()
                if j.pos > j.pos_max or j.pos < j.pos_min:
                    guitxt.color(255,0,0)
                guitxt.text("Pos raw: " + str(j.pos_raw))
                guitxt.text("Position: %s (%s..%s)"%(j.pos, j.pos_min, j.pos_max))
                guitxt.color(0,255,0)
                guitxt.text("Command: %s"%j.command)
                guitxt.text("PWM: %s Dir:%s Reverse:%s"%(
                    j.get_pwm(),j.get_direction(), j.reverse))
                guitxt.text("Brake: %s"%j.brake_cmd)
                guitxt.color(0,255,0) if j.active else guitxt.color(0,100,0)
                guitxt.text("Active: %s"%j.active)
                guitxt.indent()
                guitxt.text("Target: %s"%j.target)
                guitxt.text("Error: %s"%j.error)
                guitxt.text("Deadzone: %s"%j.deadzone)
                guitxt.text("P:%s I:%s D:%s"%(j.pid.Kp, j.pid.Ki, j.pid.Kd))
                guitxt.unindent()
                guitxt.unindent()
            guitxt.color(0,255,0)
            guitxt.text("Status %s"%eye.status)
            guitxt.text("Command %s"%eye.last_cmd)

        # Go ahead and update the screen with what we've drawn.
        pygame.display.flip()

