#!/usr/bin/env python

from __future__ import print_function
import sys
from serial import Serial, SerialException
from time import sleep
import pygame

port = '/dev/ttyUSB0'
# Read port from command line if set
if len(sys.argv) > 1:
    port = sys.argv[1]

dead_zone = 0.1
# Used to scale the joystick axis
max_pwm = 100

# 1 same as status from arduino (glitchy!). 4 = every 4 statuses etc
command_rate = 4

def loginfo(*msg):
    print("INFO:", *msg)

def logerr(*msg):
    print("ERROR:", *msg, file=sys.stderr)


class Joint(object):
    """A single joint on the eye (yaw, pitch, lid), covers sensor and motor."""
    def __init__(self, name):
        self.name      = name
        self.command   = 0
        self.pos       = 0
        self.brake_cmd = 0

    def get_pwm(self):
        # Dont try to drive motors while breaking
        if self.brake_cmd:
            return 0
        pwm = abs(self.command)
        if pwm > 255:
            pwm = 255
        return pwm

    def get_direction(self):
        if self.command < 0:
            return 0
        return 1

    def get_brake_cmd(self):
        if self.brake_cmd:
            return 1
        return 0

class ArcEye(object):
    """
    Object representing a complete eye, which it connects to over the serial
    link to the arduino. Recieves status and sends commands. Manages a set of
    Joint objects for the yaw, pitch and lid joints.
    """
    def __init__(self, port="/dev/ttyUSB0"):
        self.port   = port
        self.status = None
        self.yaw    = Joint("yaw")
        self.pitch  = Joint("pitch")
        self.lid    = Joint("lid")

    def all_joints(self):
        return (self.yaw, self.pitch, self.lid)

    def connect(self):
        try:
            self.ser = Serial(port, 9600)
        except SerialException as e:
            logerr("Failed to connect to arduino serial. Is it plugged in?\n", e)
            return False
        sleep(3) # wait for the board to reset
        loginfo("Connected to %s"%port)
        return True

    def read_status(self):
        try:
            self.status = self.ser.readline()
            self.status = self.status.strip()
            for stat in self.status.split(";"):
                if not stat or stat == "":
                    continue
                (name, value) = stat.split("=")
                jname = "UnknownJoint"
                joint = None
                if name == "yaw_pos":
                    joint = self.yaw
                elif name == "pitch_pos":
                    joint = self.pitch
                elif name == "lid_pos":
                    joint = self.lid
                else:
                    logerr("Unknown joint in status %s"%name)
                    continue
                joint.pos = value
        except Exception as e:
            logerr(e)

    def send_commands(self):
        cmd = ""
        cmd = "%s,%s,%s,%s,%s,%s,%s,%s,%s\n"%(
            self.yaw.get_pwm(), self.yaw.get_direction(), self.yaw.get_brake_cmd(),
            self.pitch.get_pwm(), self.pitch.get_direction(), self.pitch.get_brake_cmd(),
            self.lid.get_pwm(), self.lid.get_direction(), self.lid.get_brake_cmd(),
                )
        self.ser.write(cmd)


# This is a simple pygame class that will help us print to the screen
class TextPrint:
    def __init__(self, screen, text_color=(0,255,0), font=None):
        self.reset()
        self.screen     = screen
        self.font       = pygame.font.Font(None, 20) if not font else font
        self.text_color = text_color

    def text(self, textString):
        textBitmap = self.font.render(textString, True, self.text_color)
        self.screen.blit(textBitmap, [self.x, self.y])
        self.y += self.line_height

    def reset(self):
        self.x = 10
        self.y = 10
        self.line_height = 15

    def indent(self):
        self.x += 10

    def unindent(self):
        self.x -= 10


# Util func to clamp a value in a deadzone
def dead_zoned(val, dead_zone=dead_zone):
    if val > -dead_zone and val < dead_zone:
        return 0
    return val


# Start the eye
eye = ArcEye(port)
eye.connect()

# Start the gui
pygame.init()
pygame.display.set_caption("ArcEye")
screen = pygame.display.set_mode( (320,240) )
screen.fill((0, 0, 0))
guitxt = TextPrint(screen)

# Grab the joystick
joystick = None
pygame.joystick.init()
try:
    joystick = pygame.joystick.Joystick(0)
    joystick.init()
    loginfo("Joystick 0")
except pygame.error as e:
    logerr("Joystick fail %s"%e)

# Main loop
frame = 0
done = False
while not done:
        frame += 1
        #pygame.event.pump()
        for event in pygame.event.get(): # User did something
            if event.type == pygame.QUIT: # If user clicked close
                done=True # Flag that we are done so we exit this loop
            elif event.type == pygame.JOYAXISMOTION:
                eye.yaw.command = dead_zoned(joystick.get_axis(0)) * max_pwm;
                eye.pitch.command = dead_zoned(joystick.get_axis(1)) * max_pwm;
                eye.lid.command = dead_zoned(joystick.get_axis(2)) * max_pwm;
            if event.type == pygame.JOYBUTTONDOWN:
                print("Joystick button pressed.")
            if event.type == pygame.JOYBUTTONUP:
                print("Joystick button released.")

        keys = pygame.key.get_pressed()
        if keys[pygame.K_ESCAPE]:
                done = True
        elif keys[pygame.K_SPACE]:
            for j in eye.all_joints():
                j.command = 0
        elif keys[pygame.K_a]:
            eye.yaw.command += 1
        elif keys[pygame.K_d]:
            eye.yaw.command -= 1
        elif keys[pygame.K_w]:
            eye.pitch.command += 1
        elif keys[pygame.K_s]:
            eye.pitch.command -= 1
        elif keys[pygame.K_r]:
            eye.yaw.brake_cmd = 1
        elif keys[pygame.K_f]:
            eye.yaw.brake_cmd = 0
        elif keys[pygame.K_t]:
            eye.pitch.brake_cmd = 1
        elif keys[pygame.K_g]:
            eye.pitch.brake_cmd = 0
        elif keys[pygame.K_y]:
            eye.lid.brake_cmd = 1
        elif keys[pygame.K_h]:
            eye.lid.brake_cmd = 0

        eye.read_status()

        if frame % command_rate == 0:
            eye.send_commands()

        screen.fill((0,0,0))
        guitxt.reset()
        guitxt.text("Frame: %s"%frame)
        #guitxt.text("Status %s"%eye.status)
        guitxt.text("")
        for j in eye.all_joints():
            guitxt.text(j.name)
            guitxt.indent()
            guitxt.text("Position: " + str(j.pos))
            guitxt.text("Command: %s"%j.command)
            guitxt.text("Brake: %s"%j.brake_cmd)
            guitxt.unindent()

        # Go ahead and update the screen with what we've drawn.
        pygame.display.flip()
